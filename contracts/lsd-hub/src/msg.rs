use cosmwasm_schema::{cw_serde, QueryResponses};
use cosmwasm_std::{Addr, Decimal, Uint128};
use cw20::{Cw20Coin, Cw20ReceiveMsg};
use cw20_base::msg::InstantiateMarketingInfo;
use cw_controllers::ClaimsResponse;

#[cw_serde]
pub struct TokenInitInfo {
    /// Code ID of the CW20 token contract
    pub cw20_code_id: u64,
    /// A label for the token contract displayed on block explorers
    pub label: String,
    /// The instantiate fields for a CW20 contract with the exception of `mint`. The hub contract will be the only minter
    pub name: String,
    pub symbol: String,
    pub decimals: u8,
    pub initial_balances: Vec<Cw20Coin>,
    pub marketing: Option<InstantiateMarketingInfo>,
}

#[cw_serde]
pub struct InstantiateMsg {
    // This address collects a commission from the rewards
    pub treasury: String,
    /// This is the percentage of the collected rewards sent to the treasury
    pub comission: Decimal,

    /// The owner/admin of the created CW20
    pub owner: String,
    /// All tokens are bonded to these validators with the given weights
    pub validators: Vec<(String, Decimal)>,
    pub cw20_init: TokenInitInfo,
    /// How often reinvest is to be executed, in seconds
    pub epoch_period: u64,
    /// The staking module's unbonding time, in seconds
    pub unbond_period: u64,
    /// The maximum number of unbonding queue entries per validator at any time.
    /// On juno this is 7
    pub max_concurrent_unbondings: u64,

    /// The expected discount applied to the underlying value of the staking token in the [`QueryMsg::TargetValue`] query.
    /// The idea here is that no one will want to buy the staking token at exactly the price of the underlying,
    /// because they are locked and can potentially be slashed. So we apply a discount to the price.
    pub liquidity_discount: Decimal,
}

#[cw_serde]
pub enum ExecuteMsg {
    /// Implements the Cw20 receiver interface, allowing Sending wyAsset in order to unbond
    Receive(Cw20ReceiveMsg),
    /// Set staking Asset to bond to mint wyAsset
    Bond {},
    /// Claim the tokens you previously withdrew after the unbonding period has passed
    Claim {},
    /// Reinvest should be called periodically (and permissionlessly) by a cronjob to
    ///  trigger delegations, unbonding, and exchange rate recalculations.
    Reinvest {},
    /// Sets new list of validators
    SetValidators {
        new_validators: Vec<(String, Decimal)>,
    },
    /// Updates the liquidity discount used for the [`QueryMsg::TargetValue`] query
    UpdateLiquidityDiscount { new_discount: Decimal },
}

#[cw_serde]
pub enum ReceiveMsg {
    /// Submit an unbonding request to the current unbonding queue by sending your cw20 tokens
    Unbond {},
}

#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(ConfigResponse)]
    Config {},

    /// Outstanding claims generated by a previous call to Unbond{}. After the chain's native
    /// unbonding period, they can be withdrawn.
    #[returns(ClaimsResponse)]
    Claims { address: String },

    /// The current validator set and percentages where the tokens are being distributed.
    #[returns(ValidatorSetResponse)]
    ValidatorSet {},

    /// The last time Reinvest was called, and the next time it can be called.
    /// To enable a cron job to ping when needed
    #[returns(ReinvestResponse)]
    LastReinvest {},

    /// Returns data about TVL, issued tokens, claims
    #[returns(SupplyResponse)]
    Supply {},

    /// Returns the number of native staking tokens backing each cw20 token issued by this contract.
    /// That determines the rate for bonding and unbonding.
    #[returns(ExchangeRateResponse)]
    ExchangeRate {},

    /// Like `ExchangeRate` but with the liquidity discount applied.
    /// This is used by the stable swap contract to determine what price to concentrate the liquidity around
    #[returns(TargetValueResponse)]
    TargetValue {},
}

#[cw_serde]
pub struct ValidatorSetResponse {
    /// The current validator set and each validators respective weight
    pub validator_set: Vec<(String, Decimal)>,
}

#[cw_serde]
pub struct ReinvestResponse {
    /// The time in seconds the last reinvest occured
    pub last_reinvest: u64,
    /// The time in seconds the next reinvest should occur
    pub next_reinvest: u64,
}

#[cw_serde]
pub struct ExchangeRateResponse {
    /// Current exchange rate between the LSD token (always appreciating) and the underlying native token.
    /// This should satisfy: `exchange_rate * lsd_amount = native_amount`
    pub exchange_rate: Decimal,
}

/// Like `ExchangeRateResponse` but with the liquidity discount applied
#[cw_serde]
pub struct TargetValueResponse {
    /// Current exchange rate between the LSD token and the underlying native token minus liquidity discount
    pub target_value: Decimal,
}

#[cw_serde]
pub struct ConfigResponse {
    pub owner: Addr,
    pub token_contract: Addr,
    pub treasury: Addr,
    pub commission: Decimal,
    pub epoch_period: u64,
    pub unbond_period: u64,
}

#[cw_serde]
pub struct SupplyResponse {
    pub supply: Supply,
}

#[cw_serde]
#[derive(Default)]
pub struct Supply {
    /// This is the denomination we can stake (and only one we accept for payments)
    pub bond_denom: String,
    /// issued is how many derivative tokens this contract has issued
    pub issued: Uint128,
    /// total_bonded how many native tokens exist bonded to the validators in total
    pub total_bonded: Uint128,
    /// claims is how many tokens need to be reserved paying back those who unbonded
    pub claims: Uint128,
    /// the total amount of tokens that are currently unbonding
    /// this should always be equal to `supply.unbonding.into_iter().map(|u| u.amount).sum()`
    pub total_unbonding: Uint128,
}

#[cw_serde]
pub struct MigrateMsg {}
